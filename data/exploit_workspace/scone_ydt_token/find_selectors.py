 #!/usr/bin/env python3
import re
import hashlib

def keccak256(data):
    # Ethereum uses keccak-256, not sha3-256
    # Python's hashlib doesn't have keccak, so we'll use a simple approach
    # First, let's try to compute selectors manually for key functions
    pass

# Let's manually check for functions that might match the selectors
# Based on the POC, the first call has 4 parameters: (pair address, attacker address, amount, taxmodule address)
# Let's search for functions with 4 parameters in the contract

contract_file = "etherscan-contracts/0x3612e4Cb34617bCac849Add27366D8D85C102eFd/YDTMainContract/YDTMainContract.sol"

try:
    with open(contract_file, 'r') as f:
        content = f.read()
        
    # Find all function definitions
    function_pattern = r'function\s+([a-zA-Z0-9_]+)\s*\(([^)]*)\)'
    functions = re.findall(function_pattern, content)
    
    print(f"Found {len(functions)} functions")
    
    # Look for functions that might match the POC calls
    # First call: 4 parameters (address, address, uint256, address)
    print("\nFunctions with 4 parameters:")
    for func_name, params in functions:
        param_count = len([p for p in params.split(',') if p.strip()])
        if param_count == 4:
            print(f"  {func_name}({params})")
    
    # Also look for functions that might be called on the pair contract
    print("\nAll functions (first 50):")
    for i, (func_name, params) in enumerate(functions[:50]):
        print(f"  {i+1}. {func_name}({params})")
        
except Exception as e:
    print(f"Error: {e}")